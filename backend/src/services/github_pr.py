"""
GitHub PR creation service.
Creates branches and pull requests with generated infrastructure files.
"""

import logging
from typing import List, Dict, Any
from src.services.github_app import GitHubAppService

logger = logging.getLogger(__name__)


class GitHubPRService:
    """Service for creating PRs with generated infrastructure."""
    
    def __init__(self, github_app: GitHubAppService):
        self.github = github_app
    
    async def create_infrastructure_pr(
        self,
        installation_id: int,
        owner: str,
        repo: str,
        session_id: str,
        files: List[Dict[str, Any]],
        context: Dict[str, Any],
        base_branch: str = "main"
    ) -> Dict[str, Any]:
        """
        Create PR with generated infrastructure files.
        
        Args:
            installation_id: GitHub App installation ID
            owner: Repository owner
            repo: Repository name
            session_id: Workflow session ID
            files: List of generated files with 'filename' and 'content'
            context: Project context from analysis
            base_branch: Base branch to create PR against
            
        Returns:
            {
                'pr_number': int,
                'pr_url': str,
                'branch': str
            }
        """
        branch_name = f"sirpi/infrastructure-{session_id[:8]}"
        
        logger.info(f"Creating infrastructure PR for {owner}/{repo}")
        
        try:
            # 1. Get base branch SHA (with automatic fallback to master/default)
            base_ref = await self._get_branch_ref(
                installation_id, owner, repo, base_branch
            )
            
            # Use the actual branch that was found (might be different from requested)
            actual_base_branch = base_ref.get('branch', base_branch)
            base_sha = base_ref['sha']
            
            logger.info(f"Using base branch: {actual_base_branch} (SHA: {base_sha[:8]})")
            
            # 2. Create new branch
            await self._create_branch(
                installation_id, owner, repo, branch_name, base_sha
            )
            
            # 3. Generate deployment README
            readme = self._generate_deployment_readme(context, session_id)
            
            # 4. Commit all files
            for file in files:
                # Put Terraform files in terraform/ directory
                if file['filename'].endswith('.tf'):
                    path = f"terraform/{file['filename']}"
                else:
                    path = file['filename']
                
                await self.github.create_or_update_file(
                    installation_id=installation_id,
                    owner=owner,
                    repo=repo,
                    path=path,
                    content=file['content'],
                    message=f"Add {file['filename']} (generated by Sirpi)",
                    branch=branch_name
                )
                logger.info(f"Committed {path} to {branch_name}")
            
            # 5. Add deployment README
            await self.github.create_or_update_file(
                installation_id=installation_id,
                owner=owner,
                repo=repo,
                path="DEPLOYMENT.md",
                content=readme,
                message="Add deployment instructions",
                branch=branch_name
            )
            
            # 6. Create pull request
            pr_body = self._generate_pr_body(session_id, context)
            
            pr = await self.github.create_pull_request(
                installation_id=installation_id,
                owner=owner,
                repo=repo,
                title="🚀 Add AWS Infrastructure (Generated by Sirpi)",
                body=pr_body,
                head_branch=branch_name,
                base_branch=actual_base_branch  # Use the actual branch we found
            )
            
            logger.info(f"Created PR #{pr['number']}: {pr['html_url']}")
            
            return {
                'pr_number': pr['number'],
                'pr_url': pr['html_url'],
                'branch': branch_name
            }
            
        except Exception as e:
            logger.error(f"Failed to create PR: {e}", exc_info=True)
            raise
    
    async def _get_branch_ref(
        self,
        installation_id: int,
        owner: str,
        repo: str,
        branch: str
    ) -> Dict[str, str]:
        """Get branch reference SHA with fallback to common branch names."""
        token = await self.github.get_installation_token(installation_id)
        
        import httpx
        
        # Try the specified branch first
        branches_to_try = [branch]
        
        # Add fallbacks if the specified branch is main/master
        if branch == "main":
            branches_to_try.append("master")
        elif branch == "master":
            branches_to_try.append("main")
        
        async with httpx.AsyncClient() as client:
            last_error = None
            
            for branch_name in branches_to_try:
                response = await client.get(
                    f"{self.github.github_api_base}/repos/{owner}/{repo}/git/refs/heads/{branch_name}",
                    headers={
                        "Authorization": f"Bearer {token}",
                        "Accept": "application/vnd.github+json",
                        "X-GitHub-Api-Version": "2022-11-28",
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    logger.info(f"Found branch '{branch_name}' with SHA: {data['object']['sha'][:8]}")
                    return {'sha': data['object']['sha'], 'branch': branch_name}
                else:
                    last_error = f"{branch_name}: {response.status_code}"
                    logger.warning(f"Branch '{branch_name}' not found: {response.status_code}")
            
            # If none found, try to get default branch
            logger.info("Trying to get default branch from repository info...")
            repo_response = await client.get(
                f"{self.github.github_api_base}/repos/{owner}/{repo}",
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github+json",
                    "X-GitHub-Api-Version": "2022-11-28",
                }
            )
            
            if repo_response.status_code == 200:
                repo_data = repo_response.json()
                default_branch = repo_data.get('default_branch', 'main')
                logger.info(f"Repository default branch: {default_branch}")
                
                if default_branch not in branches_to_try:
                    # Try default branch
                    default_response = await client.get(
                        f"{self.github.github_api_base}/repos/{owner}/{repo}/git/refs/heads/{default_branch}",
                        headers={
                            "Authorization": f"Bearer {token}",
                            "Accept": "application/vnd.github+json",
                            "X-GitHub-Api-Version": "2022-11-28",
                        }
                    )
                    
                    if default_response.status_code == 200:
                        data = default_response.json()
                        logger.info(f"Using default branch '{default_branch}' with SHA: {data['object']['sha'][:8]}")
                        return {'sha': data['object']['sha'], 'branch': default_branch}
            
            raise Exception(f"Failed to get branch ref: tried {branches_to_try}, last error: {last_error}")
    
    async def _create_branch(
        self,
        installation_id: int,
        owner: str,
        repo: str,
        branch_name: str,
        base_sha: str
    ):
        """Create a new branch from base SHA."""
        token = await self.github.get_installation_token(installation_id)
        
        import httpx
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.github.github_api_base}/repos/{owner}/{repo}/git/refs",
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github+json",
                    "X-GitHub-Api-Version": "2022-11-28",
                },
                json={
                    "ref": f"refs/heads/{branch_name}",
                    "sha": base_sha
                }
            )
            
            if response.status_code not in [201, 422]:  # 422 = already exists
                raise Exception(f"Failed to create branch: {response.status_code}")
    
    def _generate_pr_body(self, session_id: str, context: Dict[str, Any]) -> str:
        """Generate PR description."""
        framework = context.get('framework', 'application')
        deployment_target = context.get('deployment_target', 'fargate')
        
        return f"""## 🚀 Infrastructure Generated by Sirpi

### What's Included:
- ✅ Production-ready Dockerfile for **{framework}**
- ✅ Complete Terraform infrastructure (**ECS {deployment_target.upper()}**)
- ✅ AWS resources: VPC, ALB, ECS, ECR, IAM roles

### Generated Resources:
- **VPC**: Multi-AZ with public/private subnets across 2 availability zones
- **Application Load Balancer**: HTTPS-ready (requires ACM certificate)
- **ECS Fargate**: Serverless container service with auto-scaling
- **ECR Repository**: Private Docker image registry
- **IAM Roles**: Least-privilege task execution and task roles
- **CloudWatch Logs**: Centralized application logging
- **Security Groups**: Network isolation and access control

### Architecture:
```
Internet → ALB (Public Subnets) → ECS Tasks (Private Subnets) → NAT Gateway → Internet
```

### Next Steps:

#### 1. Review Generated Files
- Check `Dockerfile` for your application configuration
- Review `terraform/*.tf` files for infrastructure setup
- Read `DEPLOYMENT.md` for detailed deployment instructions

#### 2. Merge This PR
Once you're satisfied with the generated configuration, merge this PR to add the infrastructure to your repository.

#### 3. Deploy to AWS
Follow the instructions in `DEPLOYMENT.md` to:
1. Create an ACM certificate for HTTPS
2. Configure AWS credentials
3. Build and push your Docker image
4. Deploy infrastructure with Terraform

### Estimated Monthly Cost:
**$50-100 USD** (based on 2 Fargate tasks, ALB, and NAT Gateway)

### Support:
- 📚 [Documentation](https://docs.sirpi.dev)
- 💬 [Discord Community](https://discord.gg/sirpi)
- 🐛 [Report Issues](https://github.com/sirpi/sirpi/issues)

---

<sub>Generated by [Sirpi](https://sirpi.dev) • Session: `{session_id}` • [View Logs](https://sirpi.dev/generation/{session_id})</sub>
"""
    
    def _generate_deployment_readme(
        self,
        context: Dict[str, Any],
        session_id: str
    ) -> str:
        """Generate deployment instructions README."""
        framework = context.get('framework', 'application')
        app_port = context.get('ports', [3000])[0]
        
        return f"""# AWS Deployment Guide

Infrastructure generated by [Sirpi](https://sirpi.dev) for your **{framework}** application.

## 📋 Prerequisites

Before deploying, ensure you have:

- ✅ AWS Account with appropriate permissions (VPC, ECS, ALB, IAM, ECR)
- ✅ [AWS CLI](https://aws.amazon.com/cli/) installed and configured
- ✅ [Terraform](https://www.terraform.io/downloads) >= 1.5.0
- ✅ [Docker](https://www.docker.com/get-started) installed
- ✅ [ACM Certificate](https://console.aws.amazon.com/acm) for HTTPS (must be in us-west-2)

## 🚀 Quick Start

### Step 1: Create ACM Certificate

1. Go to AWS Certificate Manager in `us-west-2` region
2. Request a public certificate for your domain
3. Validate the certificate (DNS or Email)
4. Copy the certificate ARN (needed for Terraform)

### Step 2: Configure Terraform Variables

Create `terraform/terraform.tfvars`:

```hcl
app_name               = "myapp"
environment            = "production"
region                 = "us-west-2"
acm_certificate_arn    = "arn:aws:acm:us-west-2:ACCOUNT:certificate/CERT_ID"

# Optional: Customize these
container_cpu          = 256   # 0.25 vCPU
container_memory       = 512   # 512 MB
desired_count          = 2     # Number of tasks
vpc_cidr              = "10.0.0.0/16"
```

### Step 3: Build and Push Docker Image

```bash
# 1. Get your AWS account ID
export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

# 2. Create ECR repository
aws ecr create-repository --repository-name myapp-repo --region us-west-2

# 3. Login to ECR
aws ecr get-login-password --region us-west-2 | \\
  docker login --username AWS --password-stdin \\
  $AWS_ACCOUNT_ID.dkr.ecr.us-west-2.amazonaws.com

# 4. Build Docker image
docker build -t myapp .

# 5. Tag image
docker tag myapp:latest \\
  $AWS_ACCOUNT_ID.dkr.ecr.us-west-2.amazonaws.com/myapp-repo:latest

# 6. Push to ECR
docker push $AWS_ACCOUNT_ID.dkr.ecr.us-west-2.amazonaws.com/myapp-repo:latest
```

### Step 4: Deploy Infrastructure with Terraform

```bash
# Navigate to terraform directory
cd terraform

# Initialize Terraform
terraform init

# Review what will be created
terraform plan

# Deploy infrastructure (takes 5-10 minutes)
terraform apply

# Get the ALB DNS name
terraform output alb_dns_name
```

### Step 5: Access Your Application

After deployment completes:

1. Get the ALB DNS name: `terraform output alb_dns_name`
2. Create a CNAME record in your DNS pointing to the ALB
3. Wait 2-3 minutes for ECS tasks to start
4. Visit your domain!

## 📊 Outputs

After successful deployment, Terraform provides:

```bash
terraform output alb_dns_name           # Access your application here
terraform output ecr_repository_url     # Docker image repository
terraform output ecs_cluster_name       # ECS cluster for monitoring
terraform output cloudwatch_log_group   # Application logs
```

## 🔍 Monitoring

### View Application Logs

```bash
# Tail logs in real-time
aws logs tail /ecs/myapp --follow --region us-west-2
```

### Check ECS Service Status

```bash
aws ecs describe-services \\
  --cluster myapp-cluster \\
  --services myapp-service \\
  --region us-west-2
```

## 🐛 Troubleshooting

### Container fails health check

**Problem**: ECS tasks start but immediately become unhealthy.

**Solution**:
1. Check CloudWatch logs: `aws logs tail /ecs/myapp --follow`
2. Verify your app responds on port {app_port}
3. Test health check endpoint locally: `curl http://localhost:{app_port}/`

### Terraform apply fails

**Common issues**:
- Missing ACM certificate ARN in `terraform.tfvars`
- Insufficient IAM permissions
- Resource name conflicts (change `app_name` variable)

### Cannot access application

**Checklist**:
1. Wait 2-3 minutes for ECS tasks to reach "RUNNING" state
2. Check security groups allow inbound traffic on ports 80/443
3. Verify ACM certificate is valid and matches your domain
4. Check Route53 CNAME points to ALB DNS name

## 💰 Cost Estimate

Approximate monthly costs (us-west-2):

| Resource | Cost |
|----------|------|
| ECS Fargate (2 tasks, 0.25 vCPU, 512 MB) | ~$15 |
| Application Load Balancer | ~$20 |
| NAT Gateway | ~$30 |
| Data Transfer | ~$5 |
| ECR Storage | ~$1 |
| CloudWatch Logs | ~$2 |
| **Total** | **~$73/month** |

To reduce costs:
- Use 1 task instead of 2 (`desired_count = 1`)
- Use t3.micro EC2 instead of Fargate
- Enable S3 VPC endpoints to reduce NAT costs

## 🧹 Cleanup

To destroy all resources:

```bash
cd terraform
terraform destroy
```

**Warning**: This will delete:
- All ECS tasks and services
- Load balancer and target groups
- VPC, subnets, and networking
- ECR repository and images
- CloudWatch log groups

## 📚 Architecture Details

### Network Architecture:
- **VPC**: Isolated network with DNS enabled
- **Public Subnets**: For ALB (0.0.0.0/0 internet access)
- **Private Subnets**: For ECS tasks (internet via NAT)
- **Multi-AZ**: Resources spread across 2 availability zones

### Security:
- ECS tasks run in private subnets (no direct internet access)
- Security groups restrict traffic (ALB → ECS on port {app_port} only)
- IAM roles follow least-privilege principles
- Container runs as non-root user

### Scaling:
- Auto-scaling configured (min 2, max 10 tasks)
- Circuit breaker enabled (auto-rollback on failures)
- Health checks on both ALB and container level

## 🆘 Support

Need help?
- 📖 [Sirpi Documentation](https://docs.sirpi.dev)
- 💬 [Discord Community](https://discord.gg/sirpi)
- 📧 [Email Support](mailto:support@sirpi.dev)

---

<sub>Generated by Sirpi • Session: {session_id} • [View Original Generation](https://sirpi.dev/generation/{session_id})</sub>
"""


def get_github_pr_service() -> GitHubPRService:
    """Get GitHub PR service instance."""
    from src.services.github_app import get_github_app
    return GitHubPRService(get_github_app())
